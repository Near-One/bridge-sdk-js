---
title: Relayer Fees
description: Use relayers for automatic transfer finalization
---

## Overview

Cross-chain transfers require finalization on the destination chain. You have two options:

| Approach | Pros | Cons |
|----------|------|------|
| **With Relayer** | Automatic, no extra work | Requires fee payment |
| **Manual** | No fees required | Must finalize yourself |

## How Relayers Work

When you include sufficient fees in your transfer:

1. **Initiate** — You submit the transfer on the source chain with fees
2. **Monitor** — Relayers in the network detect your transfer
3. **Wait for Finality** — Relayers wait for source chain confirmation
4. **Finalize** — A relayer submits the finalization transaction on the destination chain
5. **Claim** — The relayer claims your fee as compensation

<Note>
  The relayer network is decentralized. Multiple relayers compete to finalize transfers, ensuring reliability and speed.
</Note>

## Getting Fee Quotes

Use the API client to get current fee quotes:

```typescript
import { BridgeAPI } from "@omni-bridge/core"

const api = new BridgeAPI("mainnet")

const fee = await api.getFee(
  "eth:0xSenderAddress...",           // sender
  "near:recipient.near",               // recipient
  "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",  // token (USDC)
  1000000n                             // amount
)

console.log({
  tokenFee: fee.transferred_token_fee,  // Fee in transfer token
  nativeFee: fee.native_token_fee,      // Fee in native token (ETH)
})
```

## Including Fees in Transfers

Pass the fee values to `validateTransfer()`:

```typescript
import { createBridge, ChainKind } from "@omni-bridge/core"
import { createEvmBuilder } from "@omni-bridge/evm"

const bridge = createBridge({ network: "mainnet" })
const evm = createEvmBuilder({ network: "mainnet", chain: ChainKind.Eth })
const api = new BridgeAPI("mainnet")

// Get fee quote
const fee = await api.getFee(
  "eth:0xSender...",
  "near:recipient.near",
  "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  1000000n
)

// Validate with fees
const validated = await bridge.validateTransfer({
  token: "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  amount: 1000000n,
  fee: BigInt(fee.transferred_token_fee ?? "0"),      // Deducted from amount
  nativeFee: fee.native_token_fee ?? 0n,     // Paid in ETH
  sender: "eth:0xSender...",
  recipient: "near:recipient.near",
})

// Build and send
const tx = evm.buildTransfer(validated)
await walletClient.sendTransaction(tx)
```

## Fee Types

The bridge supports **two fee payment methods**. You can use either one, or a combination of both:

<Tabs>
  <Tab title="Token Fee (fee)">
    **Paid in the token being transferred.**
    
    - Deducted from your transfer amount
    - Recipient receives `amount - fee`
    - Good when you want to pay from the transfer itself
    
    ```typescript
    // Sending 100 USDC with 1 USDC fee
    // Recipient receives 99 USDC
    const validated = await bridge.validateTransfer({
      amount: 100_000_000n,  // 100 USDC
      fee: 1_000_000n,       // 1 USDC token fee
      nativeFee: 0n,
      // ...
    })
    ```
  </Tab>
  
  <Tab title="Native Fee (nativeFee)">
    **Paid in the source chain's native token (ETH, SOL, NEAR, etc.).**
    
    - Paid separately from the transfer amount
    - Recipient receives the full amount
    - Good when you want to preserve the full transfer amount
    
    ```typescript
    // Sending 100 USDC, paying fee in ETH
    // Recipient receives full 100 USDC
    const validated = await bridge.validateTransfer({
      amount: 100_000_000n,           // 100 USDC
      fee: 0n,
      nativeFee: 1_000_000_000_000_000n,  // 0.001 ETH
      // ...
    })
    ```
  </Tab>
  
  <Tab title="Combined">
    **Split payment between both fee types.**
    
    The relayer accepts any weighted combination that meets the required USD value.
    
    ```typescript
    // Pay half in USDC, half in ETH
    const validated = await bridge.validateTransfer({
      amount: 100_000_000n,
      fee: 500_000n,                      // 0.5 USDC
      nativeFee: 500_000_000_000_000n,    // 0.0005 ETH
      // ...
    })
    ```
  </Tab>
</Tabs>

### How Relayers Evaluate Fees

Relayers check if your provided fees meet their minimum threshold. The logic works like this:

```
// Pseudocode for relayer fee validation
if (native_fee_required == 0 && token_fee_required == 0):
    return true  // Free transfer route
    
if (token_fee_required > 0 && native_fee_required == 0):
    return provided_token_fee >= token_fee_required
    
if (native_fee_required > 0 && token_fee_required == 0):
    return provided_native_fee >= native_fee_required
    
// Weighted combination accepted
return (provided_token_fee * native_fee_required + 
        provided_native_fee * token_fee_required) >= 
       (token_fee_required * native_fee_required)
```

<Info>
  This means you have flexibility in how you pay. If the required fee is $1, you can pay entirely in tokens, entirely in native currency, or split between both.
</Info>

## Fee Calculation

Fees are calculated based on:
- **Source chain**: Different chains have different gas costs
- **Destination chain**: Finalization costs vary
- **Token**: Some tokens may have higher fees
- **Amount**: Fees may be percentage-based for larger transfers

<Note>
  Fee quotes are valid for a limited time. For large transfers, fetch a fresh quote immediately before sending.
</Note>

## Example: All Chains

<Tabs>
  <Tab title="EVM → NEAR">
    ```typescript
    const fee = await api.getFee(
      "eth:0xSender...",
      "near:recipient.near",
      "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      1000000n
    )

    const validated = await bridge.validateTransfer({
      token: "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      amount: 1000000n,
      fee: BigInt(fee.transferred_token_fee ?? "0"),
      nativeFee: fee.native_token_fee ?? 0n,
      sender: "eth:0xSender...",
      recipient: "near:recipient.near",
    })
    ```
  </Tab>

  <Tab title="NEAR → EVM">
    ```typescript
    const fee = await api.getFee(
      "near:sender.near",
      "eth:0xRecipient...",
      "near:wrap.near",
      1000000000000000000000000n
    )

    const validated = await bridge.validateTransfer({
      token: "near:wrap.near",
      amount: 1000000000000000000000000n,
      fee: BigInt(fee.transferred_token_fee ?? "0"),
      nativeFee: fee.native_token_fee ?? 0n,
      sender: "near:sender.near",
      recipient: "eth:0xRecipient...",
    })
    ```
  </Tab>

  <Tab title="Solana → NEAR">
    ```typescript
    const fee = await api.getFee(
      "sol:SenderPublicKey...",
      "near:recipient.near",
      "sol:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      1000000n
    )

    const validated = await bridge.validateTransfer({
      token: "sol:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      amount: 1000000n,
      fee: BigInt(fee.transferred_token_fee ?? "0"),
      nativeFee: fee.native_token_fee ?? 0n,
      sender: "sol:SenderPublicKey...",
      recipient: "near:recipient.near",
    })
    ```
  </Tab>
</Tabs>

## Without Relayer Fees

If you set `fee: 0n` and `nativeFee: 0n`, relayers will ignore your transfer. You'll need to finalize it yourself on the destination chain.

See the [Manual Finalization](/guides/manual-finalization) guide for:
- How different proof systems work (MPC signatures, Merkle proofs, Wormhole VAAs)
- When transfers are ready for finalization
- Links to the finalization builder APIs

## UI Considerations

When building a UI:

```typescript
// Fetch fee when user enters amount
const fee = await api.getFee(sender, recipient, token, amount)

// Show breakdown to user
const tokenFee = BigInt(fee.transferred_token_fee ?? "0")
const nativeFee = fee.native_token_fee ?? 0n
const receiveAmount = amount - tokenFee

console.log(`
  Sending: ${formatUnits(amount, decimals)} USDC
  Fee: ${formatUnits(tokenFee, decimals)} USDC
  Native fee: ${formatEther(nativeFee)} ETH
  Recipient receives: ${formatUnits(receiveAmount, decimals)} USDC
`)
```

## Error Handling

```typescript
try {
  const fee = await api.getFee(sender, recipient, token, amount)
} catch (error) {
  if (error.message.includes("unsupported route")) {
    console.error("This transfer route is not supported")
  } else if (error.message.includes("amount too small")) {
    console.error("Amount too small for this transfer")
  } else {
    console.error("Failed to get fee quote:", error)
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Tracking Transfers" icon="magnifying-glass" href="/guides/tracking-transfers">
    Monitor transfer status
  </Card>
  <Card title="API Reference" icon="code" href="/reference/core/api-client">
    Complete API client docs
  </Card>
</CardGroup>
