---
title: Solana Transfers
description: Bridge tokens from Solana to other chains
---

## Setup

```typescript
import { createBridge } from "@omni-bridge/core"
import { createSolanaBuilder } from "@omni-bridge/solana"
import { Connection, PublicKey } from "@solana/web3.js"

const bridge = createBridge({ network: "mainnet" })
const connection = new Connection("https://api.mainnet-beta.solana.com")
const solana = createSolanaBuilder({ 
  network: "mainnet",
  connection  // optional, uses public RPC if not provided
})
```

## Transfer Flow

<Steps>
  <Step title="Validate the transfer">
    ```typescript
    const validated = await bridge.validateTransfer({
      token: "sol:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC on Solana
      amount: 1000000n, // 1 USDC (6 decimals)
      fee: 0n,
      nativeFee: 0n,
      sender: "sol:YourPublicKey...",
      recipient: "near:alice.near",
    })
    ```
  </Step>

  <Step title="Build the instructions">
    ```typescript
    const payer = new PublicKey("YourPublicKey...")
    const instructions = await solana.buildTransfer(validated, payer)
    ```
    
    <Note>
      The builder returns native `TransactionInstruction[]` from `@solana/web3.js`.
    </Note>
  </Step>

  <Step title="Create and send the transaction">
    ```typescript
    import { Transaction, sendAndConfirmTransaction } from "@solana/web3.js"

    const { blockhash } = await connection.getLatestBlockhash()
    const tx = new Transaction({
      recentBlockhash: blockhash,
      feePayer: payer,
    })
    tx.add(...instructions)

    const signature = await sendAndConfirmTransaction(connection, tx, [keypair])
    ```
  </Step>
</Steps>

## Complete Example

```typescript
import { createBridge } from "@omni-bridge/core"
import { createSolanaBuilder } from "@omni-bridge/solana"
import {
  Connection,
  Keypair,
  Transaction,
  sendAndConfirmTransaction,
} from "@solana/web3.js"

// Setup
const bridge = createBridge({ network: "mainnet" })
const connection = new Connection("https://api.mainnet-beta.solana.com")
const solana = createSolanaBuilder({ network: "mainnet", connection })

// Your keypair (in production, use a secure wallet)
const keypair = Keypair.fromSecretKey(/* your secret key */)
const payer = keypair.publicKey

// Validate transfer
const validated = await bridge.validateTransfer({
  token: "sol:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
  amount: 1000000n, // 1 USDC
  fee: 0n,
  nativeFee: 0n,
  sender: `sol:${payer.toBase58()}`,
  recipient: "near:alice.near",
})

// Build instructions
const instructions = await solana.buildTransfer(validated, payer)

// Create and send transaction
const { blockhash } = await connection.getLatestBlockhash()
const tx = new Transaction({
  recentBlockhash: blockhash,
  feePayer: payer,
})
tx.add(...instructions)

const signature = await sendAndConfirmTransaction(connection, tx, [keypair])
console.log(`Transfer signature: ${signature}`)
```

## Native SOL Transfers

For native SOL, use the default public key as the token address:

```typescript
import { PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js"

const validated = await bridge.validateTransfer({
  token: `sol:${PublicKey.default.toBase58()}`, // Native SOL
  amount: BigInt(0.1 * LAMPORTS_PER_SOL), // 0.1 SOL
  fee: 0n,
  nativeFee: 0n,
  sender: `sol:${payer.toBase58()}`,
  recipient: "near:alice.near",
})
```

## SPL Tokens

The SDK supports both SPL Token and Token-2022 programs automatically:

```typescript
// Standard SPL Token (USDC)
const validated = await bridge.validateTransfer({
  token: "sol:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  amount: 1000000n,
  // ...
})

// Token-2022 tokens work the same way
const validated = await bridge.validateTransfer({
  token: "sol:SomeToken2022Mint...",
  amount: 1000000n,
  // ...
})
```

## PDA Derivation

The builder provides methods to derive Program Derived Addresses:

```typescript
// Get bridge PDAs
const configPda = solana.deriveConfig()
const authorityPda = solana.deriveAuthority()
const vaultPda = solana.deriveVault(mintPublicKey)
const solVaultPda = solana.deriveSolVault()

// Get wrapped token mint
const wrappedMint = solana.deriveWrappedMint("near:wrap.near")
```

<Warning>
  PDA seeds must match the on-chain program exactly. Don't modify them â€” use the builder's derive methods.
</Warning>

## Using Relayer Fees

```typescript
import { BridgeAPI } from "@omni-bridge/core"

const api = new BridgeAPI("mainnet")

// Get fee quote
const fee = await api.getFee(
  `sol:${payer.toBase58()}`,
  "near:recipient.near",
  "sol:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  1000000n
)

// Include fees in transfer
const validated = await bridge.validateTransfer({
  token: "sol:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  amount: 1000000n,
  fee: BigInt(fee.transferred_token_fee),
  nativeFee: BigInt(fee.native_token_fee),
  sender: `sol:${payer.toBase58()}`,
  recipient: "near:recipient.near",
})
```

## Wormhole Integration

Solana transfers use Wormhole for cross-chain messaging. When finalizing transfers from other chains to Solana, you'll need to fetch the Wormhole VAA:

```typescript
import { getWormholeVaa } from "@omni-bridge/core"

// After initiating a transfer from another chain
const vaa = await getWormholeVaa(txSignature, "Mainnet")

// Use the VAA to finalize on Solana
const finalizeInstructions = await solana.buildFinalization(
  payload,
  signature,
  payer
)
```

<Note>
  `getWormholeVaa` waits up to 2 minutes for the VAA to be available. Wormhole guardians need time to observe and sign the message.
</Note>

## Error Handling

```typescript
import { ValidationError } from "@omni-bridge/core"

try {
  const validated = await bridge.validateTransfer(params)
  const instructions = await solana.buildTransfer(validated, payer)
  
  const tx = new Transaction()
  tx.add(...instructions)
  // ... set blockhash, feePayer
  
  await sendAndConfirmTransaction(connection, tx, [keypair])
} catch (error) {
  if (error instanceof ValidationError) {
    console.error(`Validation failed: ${error.code}`)
  } else if (error.message?.includes("insufficient funds")) {
    console.error("Not enough SOL for transaction fees")
  } else {
    console.error(`Transaction failed:`, error)
  }
}
```

## Transaction Size

Solana has transaction size limits. For complex transfers, you may need to split into multiple transactions:

```typescript
const instructions = await solana.buildTransfer(validated, payer)

if (instructions.length > 5) {
  // Split into multiple transactions if needed
  console.warn("Large instruction set - consider splitting")
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Bitcoin Transfers" icon="bitcoin" href="/guides/bitcoin-transfers">
    Bridge Bitcoin and Zcash
  </Card>
  <Card title="PDA Reference" icon="key" href="/reference/solana/pdas">
    Complete PDA documentation
  </Card>
  <Card title="Tracking Transfers" icon="magnifying-glass" href="/guides/tracking-transfers">
    Monitor transfer status
  </Card>
  <Card title="API Reference" icon="code" href="/reference/solana/create-builder">
    Complete Solana builder API
  </Card>
</CardGroup>
