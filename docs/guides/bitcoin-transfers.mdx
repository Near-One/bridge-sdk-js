---
title: Bitcoin Transfers
description: Bridge Bitcoin and Zcash to NEAR
---

<Note>
  Bitcoin and Zcash use a different flow than other chains. They're UTXO-based, so deposits generate a unique address and withdrawals require MPC signing.
</Note>

## Setup

```typescript
import { createBridge } from "@omni-bridge/core"
import { createBtcBuilder } from "@omni-bridge/btc"
import { createNearBuilder } from "@omni-bridge/near"

const bridge = createBridge({ network: "mainnet" })
const btc = createBtcBuilder({ network: "mainnet", chain: "btc" })
const nearBuilder = createNearBuilder({ network: "mainnet" })
```

For Zcash:

```typescript
const zec = createBtcBuilder({ network: "mainnet", chain: "zcash" })
```

## Deposit Flow: Bitcoin → NEAR

<Steps>
  <Step title="Get a deposit address">
    Generate a unique deposit address for your NEAR recipient:

    ```typescript
    import { ChainKind } from "@omni-bridge/core"

    const result = await bridge.getUtxoDepositAddress(
      ChainKind.Btc,
      "alice.near"  // NEAR recipient
    )

    console.log(`Send BTC to: ${result.address}`)
    ```

    <Warning>
      Each deposit address is unique to the recipient. Don't reuse addresses for different recipients.
    </Warning>
  </Step>

  <Step title="Send Bitcoin">
    Send Bitcoin to the deposit address using any wallet. Wait for confirmations.

    <Tip>
      Check the minimum deposit amount. Deposits below the minimum will not be processed.
    </Tip>
  </Step>

  <Step title="Finalize on NEAR">
    After the Bitcoin transaction is confirmed, finalize the deposit on NEAR:

    ```typescript
    import { toNearKitTransaction } from "@omni-bridge/near"
    import { Near } from "near-kit"

    const near = new Near({ network: "mainnet", privateKey: "ed25519:..." })

    // Get the deposit proof
    const proof = await btc.getDepositProof(
      "your_btc_tx_hash",
      0  // output index (vout)
    )

    // Build finalization transaction
    const finalizeTx = nearBuilder.buildUtxoDepositFinalization({
      chain: "btc",
      depositMsg: {
        recipient_id: "alice.near",
      },
      txBytes: proof.tx_bytes,
      vout: 0,
      txBlockBlockhash: proof.tx_block_blockhash,
      txIndex: proof.tx_index,
      merkleProof: proof.merkle_proof,
      signerId: "alice.near",
    })

    // Send to NEAR
    await toNearKitTransaction(near, finalizeTx).send()
    ```
  </Step>
</Steps>

### Finding the Output Index (vout)

Check your Bitcoin transaction on a block explorer:
1. Go to [blockstream.info](https://blockstream.info) or [mempool.space](https://mempool.space)
2. Find your transaction
3. Look at the outputs - find the one going to your deposit address
4. The position (0, 1, 2, ...) is your `vout`

## Withdrawal Flow: NEAR → Bitcoin

<Steps>
  <Step title="Initiate withdrawal on NEAR">
    ```typescript
    import { type UTXO } from "@omni-bridge/core"

    // First build a withdrawal plan
    const utxos: UTXO[] = await nearBuilder.getUtxoAvailableOutputs("btc")
    const config = await nearBuilder.getUtxoConnectorConfig("btc")
    const withdrawAmount = 100000n // satoshis

    const plan = btc.buildWithdrawalPlan(
      utxos,
      withdrawAmount,
      "bc1qyourbitcoinaddress...",
      config.change_address,
      2 // fee rate in sat/vB
    )

    const bridgeFee = await nearBuilder.calculateUtxoWithdrawalFee("btc", withdrawAmount)
    const totalAmount = withdrawAmount + plan.fee + bridgeFee

    const withdrawTx = nearBuilder.buildUtxoWithdrawalInit({
      chain: "btc",
      targetAddress: "bc1qyourbitcoinaddress...",
      inputs: plan.inputs,
      outputs: plan.outputs,
      totalAmount,
      signerId: "alice.near",
    })

    const result = await toNearKitTransaction(near, withdrawTx).send()
    ```
  </Step>

  <Step title="Wait for MPC signing">
    The bridge uses MPC (Multi-Party Computation) to sign Bitcoin transactions:

    ```typescript
    import { BridgeAPI } from "@omni-bridge/core"

    const api = new BridgeAPI("mainnet")

    // Poll for signed transaction
    let signedTxHash: string | undefined

    for (let i = 0; i < 60; i++) {
      const transfers = await api.getTransfer({
        transactionHash: result.transaction.hash,
      })
      const transfer = transfers[0]

      if (transfer?.signed?.NearReceipt?.transaction_hash) {
        signedTxHash = transfer.signed.NearReceipt.transaction_hash
        break
      }

      await new Promise((r) => setTimeout(r, 5000))
    }
    ```
  </Step>

  <Step title="Broadcast to Bitcoin network">
    ```typescript
    // Extract signed transaction from NEAR logs
    const signedTx = await near.getTransactionStatus(
      signedTxHash,
      "alice.near",
      "FINAL"
    )

    const signedLog = signedTx.receipts_outcome
      .flatMap((r) => r.outcome.logs)
      .find((log) => log.includes("signed_btc_transaction"))

    const jsonPart = signedLog.split("EVENT_JSON:")[1]
    const signedData = JSON.parse(jsonPart)
    const txBytes: number[] = signedData.data[0].tx_bytes

    const txHex = txBytes.map((b) => b.toString(16).padStart(2, "0")).join("")
    const btcTxHash = await btc.broadcastTransaction(txHex)
    console.log(`Bitcoin TX: ${btcTxHash}`)
    ```
  </Step>
</Steps>

## Complete Deposit Example

```typescript
import { createBridge, ChainKind } from "@omni-bridge/core"
import { createBtcBuilder } from "@omni-bridge/btc"
import { createNearBuilder, toNearKitTransaction } from "@omni-bridge/near"
import { Near } from "near-kit"

// Setup
const bridge = createBridge({ network: "mainnet" })
const btc = createBtcBuilder({ network: "mainnet", chain: "btc" })
const nearBuilder = createNearBuilder({ network: "mainnet" })
const near = new Near({ network: "mainnet", privateKey: "ed25519:..." })

// Step 1: Get deposit address
const { address } = await bridge.getUtxoDepositAddress(
  ChainKind.Btc,
  "alice.near"
)
console.log(`Send BTC to: ${address}`)

// Step 2: User sends Bitcoin externally...
const btcTxHash = "abc123..."  // From user's wallet
const vout = 0

// Step 3: Get proof and finalize
const proof = await btc.getDepositProof(btcTxHash, vout)

const finalizeTx = nearBuilder.buildUtxoDepositFinalization({
  chain: "btc",
  depositMsg: {
    recipient_id: "alice.near",
  },
  txBytes: proof.tx_bytes,
  vout,
  txBlockBlockhash: proof.tx_block_blockhash,
  txIndex: proof.tx_index,
  merkleProof: proof.merkle_proof,
  signerId: "alice.near",
})

const result = await toNearKitTransaction(near, finalizeTx).send()
console.log(`Deposit finalized! nBTC credited to alice.near`)
```

## UTXO Selection

For withdrawals, the SDK automatically selects UTXOs via `buildWithdrawalPlan`. For advanced use cases:

```typescript
import { linearFeeCalculator, type NormalizedUTXO } from "@omni-bridge/btc"

// Get available UTXOs and normalize them
const utxos = await nearBuilder.getUtxoAvailableOutputs("btc")
const normalizedUtxos: NormalizedUTXO[] = utxos.map((u) => ({
  txid: u.txid,
  vout: u.vout,
  value: BigInt(u.value),
  script_pubkey: u.script_pubkey,
}))

// Custom UTXO selection with fee calculator
const selected = btc.selectUtxos(normalizedUtxos, amount, {
  feeCalculator: linearFeeCalculator({ base: 10, input: 68, output: 31, rate: 15 }),
  dustThreshold: 546n,
})

console.log(`Using ${selected.inputs.length} inputs`)
console.log(`Total: ${selected.totalInput} satoshis`)
console.log(`Fee: ${selected.fee} satoshis`)
```

## Fee Calculation

### Bitcoin

Bitcoin uses a linear fee model based on transaction size:

```typescript
import { linearFeeCalculator } from "@omni-bridge/btc"

const calculator = linearFeeCalculator({
  base: 10,    // base tx size
  input: 68,   // size per input
  output: 31,  // size per output
  rate: 15,    // sat/vbyte
})

const fee = calculator(2, 2)  // 2 inputs, 2 outputs
```

### Zcash

Zcash uses ZIP-317 marginal fee calculation:

```typescript
import { zcashFeeCalculator, ZCASH_DUST_THRESHOLD } from "@omni-bridge/btc"

const calculator = zcashFeeCalculator()
const fee = calculator(2, 2)  // 2 inputs, 2 outputs

// Zcash has a higher dust threshold
console.log(`Dust threshold: ${ZCASH_DUST_THRESHOLD}`)  // 5000 zatoshis
```

## Checking Balances

```typescript
// Check nBTC balance on NEAR
const balance = await nearBuilder.getUtxoTokenBalance("btc", "alice.near")
console.log(`nBTC balance: ${balance} satoshis`)

// Check withdrawal fee
const fee = await nearBuilder.calculateUtxoWithdrawalFee("btc", amount)
console.log(`Withdrawal fee: ${fee} satoshis`)
```

## Connector Configuration

```typescript
const config = await nearBuilder.getUtxoConnectorConfig("btc")

console.log({
  minDeposit: config.min_deposit_amount,
  minWithdraw: config.min_withdraw_amount,
  depositFee: config.deposit_bridge_fee,
  withdrawFee: config.withdraw_bridge_fee,
})
```

## Zcash Support

Zcash works identically to Bitcoin, just change the chain parameter:

```typescript
import { ChainKind, type UTXO } from "@omni-bridge/core"

const zec = createBtcBuilder({ network: "mainnet", chain: "zcash" })

// Deposit
const { address } = await bridge.getUtxoDepositAddress(
  ChainKind.Zcash,
  "alice.near"
)

// Withdrawal
const utxos: UTXO[] = await nearBuilder.getUtxoAvailableOutputs("zcash")
const config = await nearBuilder.getUtxoConnectorConfig("zcash")

const plan = zec.buildWithdrawalPlan(
  utxos,
  100000n,
  "t1yourzcashaddress...",
  config.change_address
)

const bridgeFee = await nearBuilder.calculateUtxoWithdrawalFee("zcash", 100000n)
const totalAmount = 100000n + plan.fee + bridgeFee

const withdrawTx = nearBuilder.buildUtxoWithdrawalInit({
  chain: "zcash",
  targetAddress: "t1yourzcashaddress...",
  inputs: plan.inputs,
  outputs: plan.outputs,
  totalAmount,
  signerId: "alice.near",
})
```

<Note>
  Zcash uses transparent addresses (`t1...`). Shielded addresses are not supported.
</Note>

## Error Handling

```typescript
try {
  const proof = await btc.getDepositProof(txHash, vout)
} catch (error) {
  if (error.message.includes("not found")) {
    console.log("Transaction not found or not confirmed")
  } else if (error.message.includes("invalid vout")) {
    console.log("Wrong output index")
  }
}

try {
  const plan = btc.buildWithdrawalPlan(utxos, amount, targetAddress, changeAddress)
} catch (error) {
  if (error.message.includes("No UTXOs")) {
    console.log("No UTXOs available in bridge pool")
  } else if (error.message.includes("Insufficient")) {
    console.log("Not enough UTXOs to cover amount + fees")
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Tracking Transfers" icon="magnifying-glass" href="/guides/tracking-transfers">
    Monitor transfer status
  </Card>
  <Card title="UTXO Selection" icon="coins" href="/reference/btc/utxo-selection">
    Advanced UTXO handling
  </Card>
  <Card title="Fee Calculation" icon="calculator" href="/reference/btc/fee-calculation">
    Fee estimation APIs
  </Card>
  <Card title="API Reference" icon="code" href="/reference/btc/create-builder">
    Complete BTC builder API
  </Card>
</CardGroup>
