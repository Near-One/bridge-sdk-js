---
title: EVM Transfers
description: Bridge tokens from Ethereum, Base, Arbitrum, Polygon, and BNB Chain
---

## Setup

```typescript
import { createBridge, ChainKind } from "@omni-bridge/core"
import { createEvmBuilder } from "@omni-bridge/evm"

const bridge = createBridge({ network: "mainnet" })
const evm = createEvmBuilder({ network: "mainnet", chain: ChainKind.Eth })
```

For other EVM chains, change the `chain` parameter:

```typescript
const baseBuilder = createEvmBuilder({ network: "mainnet", chain: ChainKind.Base })
const arbBuilder = createEvmBuilder({ network: "mainnet", chain: ChainKind.Arb })
const polBuilder = createEvmBuilder({ network: "mainnet", chain: ChainKind.Pol })
const bnbBuilder = createEvmBuilder({ network: "mainnet", chain: ChainKind.Bnb })
```

## Transfer Flow

<Steps>
  <Step title="Validate the transfer">
    ```typescript
    const validated = await bridge.validateTransfer({
      token: "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
      amount: 1000000n, // 1 USDC (6 decimals)
      fee: 0n,
      nativeFee: 0n,
      sender: "eth:0xYourAddress...",
      recipient: "near:recipient.near",
    })
    ```
  </Step>

  <Step title="Approve the token (ERC20 only)">
    ```typescript
    const approvalTx = evm.buildApproval(
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      1000000n
    )
    await walletClient.sendTransaction(approvalTx)
    ```

    <Tip>
      Use `buildMaxApproval(tokenAddress)` for unlimited approval, avoiding repeated approvals.
    </Tip>
  </Step>

  <Step title="Build and send the transfer">
    ```typescript
    const tx = evm.buildTransfer(validated)
    const hash = await walletClient.sendTransaction(tx)
    ```
  </Step>
</Steps>

## Complete Examples

<Tabs>
  <Tab title="viem">
    ```typescript
    import { createBridge, ChainKind } from "@omni-bridge/core"
    import { createEvmBuilder } from "@omni-bridge/evm"
    import { createWalletClient, http, parseEther } from "viem"
    import { mainnet } from "viem/chains"
    import { privateKeyToAccount } from "viem/accounts"

    // Setup
    const bridge = createBridge({ network: "mainnet" })
    const evm = createEvmBuilder({ network: "mainnet", chain: ChainKind.Eth })

    const account = privateKeyToAccount("0x...")
    const walletClient = createWalletClient({
      chain: mainnet,
      transport: http(),
      account,
    })

    // Validate
    const validated = await bridge.validateTransfer({
      token: "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      amount: 1000000n,
      fee: 0n,
      nativeFee: 0n,
      sender: `eth:${account.address}`,
      recipient: "near:alice.near",
    })

    // Approve (for ERC20)
    const approvalTx = evm.buildApproval(
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      1000000n
    )
    await walletClient.sendTransaction(approvalTx)

    // Transfer
    const tx = evm.buildTransfer(validated)
    const hash = await walletClient.sendTransaction(tx)
    console.log(`Transfer hash: ${hash}`)
    ```
  </Tab>

  <Tab title="ethers v6">
    ```typescript
    import { createBridge, ChainKind } from "@omni-bridge/core"
    import { createEvmBuilder } from "@omni-bridge/evm"
    import { ethers } from "ethers"

    // Setup
    const bridge = createBridge({ network: "mainnet" })
    const evm = createEvmBuilder({ network: "mainnet", chain: ChainKind.Eth })

    const provider = new ethers.JsonRpcProvider("https://eth.llamarpc.com")
    const signer = new ethers.Wallet("0x...", provider)

    // Validate
    const validated = await bridge.validateTransfer({
      token: "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      amount: 1000000n,
      fee: 0n,
      nativeFee: 0n,
      sender: `eth:${signer.address}`,
      recipient: "near:alice.near",
    })

    // Approve (for ERC20)
    const approvalTx = evm.buildApproval(
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      1000000n
    )
    await signer.sendTransaction(approvalTx)

    // Transfer
    const tx = evm.buildTransfer(validated)
    const receipt = await signer.sendTransaction(tx)
    console.log(`Transfer hash: ${receipt.hash}`)
    ```
  </Tab>
</Tabs>

## Native ETH Transfers

For native ETH (not WETH), use the zero address as the token:

```typescript
const validated = await bridge.validateTransfer({
  token: "eth:0x0000000000000000000000000000000000000000", // Native ETH
  amount: parseEther("0.1"), // 0.1 ETH
  fee: 0n,
  nativeFee: 0n,
  sender: "eth:0xYourAddress...",
  recipient: "near:alice.near",
})

// No approval needed for native ETH
const tx = evm.buildTransfer(validated)
await walletClient.sendTransaction(tx)
```

<Note>
  For native token transfers, the transaction's `value` field includes both the transfer amount and any native fee.
</Note>

## Using Relayer Fees

To use the relayer network for automatic finalization on the destination chain:

```typescript
import { BridgeAPI } from "@omni-bridge/core"

const api = new BridgeAPI("mainnet")

// Get fee quote
const fee = await api.getFee(
  "eth:0xYourAddress...",
  "near:recipient.near",
  "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  1000000n
)

// Include fees in transfer
const validated = await bridge.validateTransfer({
  token: "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  amount: 1000000n,
  fee: BigInt(fee.transferred_token_fee ?? "0"),
  nativeFee: fee.native_token_fee ?? 0n,
  sender: "eth:0xYourAddress...",
  recipient: "near:recipient.near",
})
```

## L2 Chains

The same pattern works for all EVM L2s:

<Tabs>
  <Tab title="Base">
    ```typescript
    import { base } from "viem/chains"

    const evm = createEvmBuilder({ network: "mainnet", chain: ChainKind.Base })

    const walletClient = createWalletClient({
      chain: base,
      transport: http(),
      account,
    })

    const validated = await bridge.validateTransfer({
      token: "base:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", // USDC on Base
      amount: 1000000n,
      // ...
    })
    ```
  </Tab>

  <Tab title="Arbitrum">
    ```typescript
    import { arbitrum } from "viem/chains"

    const evm = createEvmBuilder({ network: "mainnet", chain: ChainKind.Arb })

    const walletClient = createWalletClient({
      chain: arbitrum,
      transport: http(),
      account,
    })

    const validated = await bridge.validateTransfer({
      token: "arb:0xaf88d065e77c8cC2239327C5EDb3A432268e5831", // USDC on Arbitrum
      amount: 1000000n,
      // ...
    })
    ```
  </Tab>
</Tabs>

## Error Handling

```typescript
import { ValidationError } from "@omni-bridge/core"

try {
  const validated = await bridge.validateTransfer(params)
  const tx = evm.buildTransfer(validated)
  await walletClient.sendTransaction(tx)
} catch (error) {
  if (error instanceof ValidationError) {
    switch (error.code) {
      case "INVALID_ADDRESS":
        console.error("Invalid address format")
        break
      case "TOKEN_NOT_REGISTERED":
        console.error("Token not supported by bridge")
        break
      case "AMOUNT_TOO_SMALL":
        console.error("Amount too small for cross-chain transfer")
        break
    }
  }
}
```

## Transaction Format

The `EvmUnsignedTransaction` returned by `buildTransfer()`:

```typescript
interface EvmUnsignedTransaction {
  to: `0x${string}`      // Bridge contract address
  data: `0x${string}`    // Encoded function call
  value: bigint          // Native token amount (for ETH transfers or native fee)
  chainId: number        // Chain ID
}
```

This format works directly with viem and ethers v6.

## Next Steps

<CardGroup cols={2}>
  <Card title="NEAR Transfers" icon="circle-nodes" href="/guides/near-transfers">
    Transfer from NEAR Protocol
  </Card>
  <Card title="Tracking Transfers" icon="magnifying-glass" href="/guides/tracking-transfers">
    Monitor transfer status
  </Card>
  <Card title="Relayer Fees" icon="money-bill" href="/guides/relayer-fees">
    Use relayers for auto-finalization
  </Card>
  <Card title="API Reference" icon="code" href="/reference/evm/create-builder">
    Complete EVM builder API
  </Card>
</CardGroup>
