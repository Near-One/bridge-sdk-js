---
title: Decimal Normalization
description: Critical concept for cross-chain transfers
---

<Warning>
  **This is the most common source of transfer failures.** Amounts that are too small may normalize to zero, causing transfers to fail silently.
</Warning>

## The Problem

Consider USDC:
- On **Ethereum**: 6 decimals (1 USDC = 1,000,000 units)
- On **NEAR**: 24 decimals (1 USDC = 1,000,000,000,000,000,000,000,000 units)

When bridging 1 USDC from Ethereum to NEAR, the SDK must scale the amount appropriately.

## How It Works

The SDK normalizes amounts to ensure they survive the round-trip between chains:

```typescript
import { normalizeAmount } from "@omni-bridge/core"

// Scaling up (Ethereum → NEAR)
const nearAmount = normalizeAmount(
  1000000n,  // 1 USDC on Ethereum (6 decimals)
  6,          // from decimals
  24          // to decimals
)
// Result: 1000000000000000000000000n (1 USDC on NEAR)

// Scaling down (NEAR → Ethereum)
const ethAmount = normalizeAmount(
  1000000000000000000000000n,  // 1 USDC on NEAR
  24,                           // from decimals
  6                             // to decimals
)
// Result: 1000000n (1 USDC on Ethereum)
```

## The Dust Problem

When scaling down from high precision to low precision, small amounts may become zero — this is known as <Tooltip tip="Amounts so small they round to zero when converted between decimal precisions, similar to dust particles that are too small to be useful.">dust</Tooltip>:

```typescript
// Trying to bridge 0.0000001 USDC from NEAR to Ethereum
const amount = 100000000000000000n  // 0.0000001 USDC on NEAR (24 decimals)

const ethAmount = normalizeAmount(amount, 24, 6)
// Result: 0n ❌ The amount is too small!
```

## Validation

The SDK provides validation functions to catch this before the transfer fails:

```typescript
import { validateTransferAmount, getMinimumTransferableAmount } from "@omni-bridge/core"

// Check if amount survives normalization (throws if not)
try {
  validateTransferAmount(
    amount,           // amount in source decimals
    fee,              // fee in source decimals
    6,                // source decimals
    24                // destination decimals
  )
} catch (error) {
  console.log("Amount too small for transfer")
}

// Get the minimum transferable amount
const minAmount = getMinimumTransferableAmount(6, 24)
// Result: 1n (smallest amount that survives the round-trip)
```

## Automatic Validation

`bridge.validateTransfer()` automatically validates decimal normalization:

```typescript
const validated = await bridge.validateTransfer({
  token: "eth:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  amount: 1n,  // Too small!
  // ...
})
// Throws ValidationError with code AMOUNT_TOO_SMALL
```

The `ValidatedTransfer` object includes normalized amounts:

```typescript
interface ValidatedTransfer {
  params: TransferParams
  sourceChain: ChainKind
  destChain: ChainKind
  normalizedAmount: bigint    // Amount in destination decimals
  normalizedFee: bigint       // Fee in destination decimals
  contractAddress: string
  bridgedToken?: OmniAddress
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Always use validateTransfer()">
    Never skip the validation step. It catches decimal issues before they cause problems on-chain.
  </Accordion>
  
  <Accordion title="Check minimum amounts in your UI">
    Use `getMinimumTransferableAmount()` to show users the minimum transferable amount for a token pair.
  </Accordion>
  
  <Accordion title="Handle ValidationError">
    Catch `ValidationError` with code `AMOUNT_TOO_SMALL` and display a helpful message.
    
    ```typescript
    try {
      await bridge.validateTransfer(params)
    } catch (error) {
      if (error.code === "AMOUNT_TOO_SMALL") {
        const min = getMinimumTransferableAmount(srcDecimals, dstDecimals)
        showError(`Minimum amount is ${formatUnits(min, srcDecimals)}`)
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Consider fees">
    The amount minus fees must also survive normalization. If you're deducting fees, validate the net amount.
  </Accordion>
</AccordionGroup>

## Common Decimal Configurations

| Token | Ethereum | NEAR | Solana |
|-------|----------|------|--------|
| USDC | 6 | 24 | 6 |
| USDT | 6 | 24 | 6 |
| WETH | 18 | 24 | 8 |
| wNEAR | 18 | 24 | 9 |

<Note>
  Use `bridge.getTokenDecimals(token)` to fetch the actual decimal configuration for any token from the bridge contract.
</Note>

## Next Steps

<CardGroup cols={2}>
  <Card title="Supported Chains" icon="link" href="/concepts/supported-chains">
    See all supported chains and tokens
  </Card>
  <Card title="Error Handling" icon="triangle-exclamation" href="/reference/core/errors">
    Handle validation errors properly
  </Card>
</CardGroup>
